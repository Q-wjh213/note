#import "/book.typ": book-page
#show: book-page.with()
#import "/css.typ": *
#set par(leading: 1.25em,spacing: 1.75em)
#import "@preview/tablem:0.2.0": tablem, three-line-table

= 整体二分

在遇到某些单个询问可以用二分解决的问题时，面对多组询问，我们思考如果能够对所有询问一并二分解决的话就可以解决整个问题。这时候，整体二分便会成为我们有力的工具。

整体二分是一种离线思想，通过将多组询问同时处理以达到很好的时间复杂度，下面我们以下面几个例子来学习。

== 全序列第 $k$ 小

#quote([
  有一个长为 $n$ 的序列 $a$，现在有 $q$ 组询问，每组询问整个序列中第 $k_i$ 小的值是多少。
  
  $1 <= n,q,k_i <= 10^5$，$0 <= a_i <= 10^9$，$a_i,n,q,k_i in ZZ$。
])

如果直接排序的话，这道题显然是简单的，那我们思考我们能否使用二分的方式解决单个询问呢?

考虑二分答案，已知 $0 <= a_i <=10^9$，说明答案肯定也在 $[0,10^9]$ 之内。不妨二分 $text("mid")$，统计整个序列中小于等于 $text("mid")$ 的数的个数，若其大于等于 $k_i$，说明最终答案一定小于等于 $text("mid")$，则 $r<--text("mid")$，否则 $l<--text("mid")+1$。若 $l=r$，则说明答案为 $l$。

那么我们如果能同时处理所有询问就好了，不难发现，在第一次求 $text("mid")$ 时，我们可以同时处理出所有询问答案和 $text("mid")$ 的关系。那么我们可以把询问分为两类：$text("ans")>text("mid")$ 和 $text("ans")<=text("mid")$。若对两类继续如此递归，复杂度肯定会爆炸。不过我们发现，在二分询问的过程中，我们同样也可以二分 $a_i$。
\ 

- 若 $text("ans") <= text("mid")$，则我们只需要在 $a_i<=text("mid")$ 的数中统计即可，因为在下一次二分中的数一定小于 $text("mid")$，显然 $a_i>text("mid")$ 的 $a_i$ 不可能被统计入答案。

- 若 $text("ans")>text("mid")$，设 $x$ 表示 $a_i<=text("mid")$ 的 $a_i$ 的数量。则我们知道下一次统计当中在这一次被统计进入的数下一次一定还会被统计，所以不妨令 $k_i<--k_i-x$，这时候我们只需要在 $a_i>text("mid")$ 中的 $a_i$ 继续递归即可。

通过这样的做法，$a_i$ 也被不停的二分到不同的区间内，且最多被分到 $log V$ 个区间内，其中 $V$ 是值域。而 $a_i$ 在每个区间内只会被统计到一次，那么总统计次数就是 $n log V$ 的。这样我们就在 $cal(O)(n log V)$ 的时间复杂度内解决了这个问题。

== 区间第 $k$ 小

#quote([
  有一个长为 $n$ 的序列 $a$，现在有 $q$ 组询问，每组询问有三个参数 $l_i,r_i,k_i$，表示询问序列 $n$ 中 $[l_i,r_i]$ 的区间第 $k_i$ 小值。
  
  $1 <= n,q,k_i <= 10^5$，$1<=l<=r<=n$，$0 <= a_i <= 10^9$，$a_i,n,q,k_i,l,r in ZZ$。
])

这一道题目当中我们显然不可能再进行排序后直接完成了，通常采用的是可持久化线段树来完成，不过也有使用整体二分的做法。

类似之前的做法，只不过之前的题目可以看成各组询问的 $l=1,r=n$。所以我们在之前的题目中在每个被二分到的区间内每个数只需要被遍历到一次。而如果这道题目我们采用同样的策略，肯定会超时，考虑怎么优化。

发现我们只需要把小于等于 $text("mid")$ 的位置从直接统计改成在数状数组上 $+1$，然后通过简单的查询就能得到每组区间的答案，这样我们就解决了这个问题。

注意清空数状数组不要直接 `memset`，可以在数状数组中反着做一遍来实现清空。

同样每个数会被访问到 $log V$ 次，单次在数状数组上修改的复杂度为 $cal(O)(log n)$，查询总复杂度为 $cal(O)(q log n log V)$，若 $n,q$ 同阶，则总复杂度可表示为 $cal(O)(n log n log V)$。

#quote2([
  *如果带修改呢？我们还可以这样完成吗？*

  实际上，我们只需要能够正确统计出以上信息，修改就并不会造成影响。

  对于修改操作，我们可以看成若数状数组中原下标已经有 `1`，则把原下标位置减去，然后再研究修改后的数是否小于等于 $text("mid")$，如果是则在数状数组上 $+1$，只要我们能保证我们按照顺序做，那么正确性就可以保证。不过第一步记忆是否有 `1` 还是稍显麻烦，而且若更改操作和原操作没有被分配到同一个区间，还会导致我们不知道原操作的 `1` 什么时候被删除，所以不妨把一次修改操作改成删除操作和添加操作，删除的下标所对应的值是原值，增加的是新值。显然只有原值小于等于 $text("mid")$ 时，我们才会进行删除操作，可以说明这样是正确的。
])

=== *例题*

#link("https://www.luogu.com.cn/problem/P3250")[[HNOI2016] 网络]

#quote[
  *题目大意：*

  给定一颗有 $n$ 个点的树，现在有三种操作：
  \
  + 添加一条路径
  + 删除一条已经被添加的路径
  + 在未删除的路径中查询不经过点 $x$ 的路径的最大权值
  \
  一共操作 $q$ 次。
  
  $1 <= n <=10^5$，$1<=q<=2times 10^5$。
]

与上一道题类似的思路，我们肯定首先要选择二分答案，问题是，我们如何判断答案是否可达呢？

发现我们其实可以这样做：二分出一个值 `mid`，如果路径权值 $>$ `mid`，就在对应路径上的所有点权 $+1$，并且定义变量 `tot`，如果新增一条路径 `tot++`，反之在删除时路径上点权 $-1$，`tot--`。对于每一次查询，只需要查找当前点点权，就可以得到有多少条路径经过它，再用 `tot` 减掉刚刚的结果，便可知在不经过他的路径中是否有权值 $>$ `mid` 的了。

考虑如何快速在树上进行操作，因为子树 dfs 序连续，所以我们可以直接在树状数组上进行操作，具体而言，设路径端点为 $u,v$，则我们在 $u,v$ 的权值 $+1$，$text("lca")(u,v)$ 以及其父亲的权值 $-1$。单点查询时，只需要查询这个点对应的子树即可。

每一个询问最多被分到 $log V$ 个区间内，在单区间内每个询问在树状数组上以 $cal(O)(log n)$ 的复杂度被修改，共有 $q$ 个询问，若 $n,q$ 同阶，则总复杂度 $cal(O)(n log n log V)$。 